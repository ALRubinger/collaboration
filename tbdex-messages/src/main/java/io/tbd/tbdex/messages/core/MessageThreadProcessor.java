package io.tbd.tbdex.messages.core;

import io.tbd.tbdex.messages.processors.MessageProcessor;

import java.util.HashMap;
import java.util.Map;

public class MessageThreadProcessor {
    MessageThread messageThread;
    Map<MessageType, MessageProcessor> messageProcessors = new HashMap<>();

    private MessageThreadProcessor() {
        this.messageThread = new MessageThread();
    }

    private void addProcessor(MessageType type, MessageProcessor processor) {
        this.messageProcessors.put(type, processor);
    }

    /**
     * Adds a message to the message thread. executes any processor registered to the
     * {@link MessageType} of the message being added (if any).
     * @param message - the message being added
     * @return A resulting message generated by processing the message being added. Returns
     *         null if the message added results in no new message
     * @throws RuntimeException - if the message being added is invalid
     */
    public Message addMessage(Message message) {
        if (message == null) {
            return null;
        }

        MessageType messageType = message.type();

        if (this.messageThread.isEmpty()) {
            // an Ask should always be the first message
            if (messageType != MessageType.Ask) {
                throw new RuntimeException("The first message in a thread can only be an Ask");
            }
        } else {
            if (messageType == MessageType.Ask) {
                throw new RuntimeException("an Ask can only be the first message in a thread");
            }

            Message lastMessage = this.messageThread.getLastMessage();
            if (!lastMessage.body().isValidReply(messageType)) {
                throw new RuntimeException(messageType + " is not a valid reply to the most recent message [" + lastMessage.type() + "]" + "in this thread");
            }
        }

        this.messageThread.addMessage(message);
        MessageProcessor processor = messageProcessors.get(message.type());

        if (processor == null) {
            return null;
        }

        Message resultingMessage = processor.process(message);
        this.addMessage(resultingMessage);

        return resultingMessage;
    }

    public static class Builder {
        private final MessageThreadProcessor instance;

        public Builder() {
            this.instance = new MessageThreadProcessor();
        }

        public Builder setMessageThread(MessageThread messageThread) {
            this.instance.messageThread = messageThread;

            return this;
        }

        /**
         * registers the {@link MessageProcessor] provided as the processor that gets called
         * whenever a message of type {@link MessageType} is added to the MessageThreadProcessor
         * using {@link MessageThreadProcessor#addMessage(Message)}. {@link MessageProcessor#process(Message)}
         * only gets called if the message being added is considered to be valid with respect to the
         * current state of the thread
         * @param type - The {@link MessageType} to register the processor to
         * @param processor - the processor to register
         * @return MessageThreadProcesor.Builder
         */
        public Builder registerProcessor(MessageType type, MessageProcessor processor) {
            this.instance.addProcessor(type, processor);

            return this;
        }

        public MessageThreadProcessor build() {
            /* TODO: Decide if we want to keep this
             if (this.instance.messageProcessors.isEmpty()) {
                throw new RuntimeException("please provide at least 1 processor");
             }
            */

            return instance;
        }
    }
}
